This project is an attempt to write a custom protocol for transmitting data with sound. It uses the Web Audio API to get or broadcast audio sample data. The system works by varying the signal between 4 frequencies, each representing a different 2 bit value. The receiver looks at sets of samples as they come in from the microphone (or straight from the source node in the case of simulating), and runs a series of Goertzel filters on the incoming samples, and if one of the filters is of a certain magnitude it stores its corresponding frequency in a buffer. Whenever a new frequency is detected, or if it is determined that there are enough entries in the buffer that the data must be repeating, the buffer is flushed and the frequency it was holding is put into another buffer. Once this buffer has 4 entries, it is then converted back to a byte.

Despite my efforts, it is still very inconsistent. I've been able to successfully transmit small messages from my phone to laptop, but that's about it. Spaces especially seem to give it trouble. When simulating, it seems to work ok, but channel conditions in real life are nowhere near as ideal. As far as I can tell, the main failing is in trying to track repeating values. My method for this is very naive and inaccurate, so I'm kind of amazed it works at all honestly.

I feel that the code in this repo is a poor indicator of how much I learned about signal processing while researching and working on this project. The tx/rx chain went through multiple 'crumple up and toss in the garbage' resets, and for most of my time working on this I was attempting to implement a BPSK scheme. I read through a decent chunk of a great ebook I found about software defined radios ('Telecommunication Breakdown' by C. R. Johnson, Jr. and W. A. Sethares if you're curious), and was really hoping to put a lot of what I was reading into action. Unfortunately, it was beyond my abilities to successfully translate the ideas I was reading and thinking about into real code. Part of this I think is my own lack of mastery over said material, and another is my choice of JavaScript and Web Audio. I'm not saying I regret going with JavaScript, but it almost certainly might have been easier doing this in Python or C++. On one hand, I did learn a lot about Web Audio and feel really comfortable with it now. On the other, I've learned that trying to do anything that involved precise timing in JavaScript is an absolute nightmare.

This module barely works and is fairly janky with very fuzzy methods of trying to extract the data from the incoming signal. In all honestly I'm surprised it works over the air at all right now. It *was* really fun to make though.